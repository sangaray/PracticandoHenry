M3-L14 - Ariel Romero - JavaScript avanzado II
Objetivos
- Aprende que es la eficiencia y la complejida de un algoritmo
- Conocer e implementar algoritmos para comparar su complejidad
- Utilizar la inteligencia artificial para mejorar la eficiencia de un c칩digo

1. Time Complexity & Space Complexity
RECURSOS
COMPLEJIDAD TEMPORAL
Representa la cantidad de tiempo que requiere un programa para ejecutarse en funci칩n del tama침o de su entrada.
Se mide normalmente en unidades de tiempo como segundos, milisegundos, etc. (este es el recurso m치s importante y dif칤cil de manejar, se espera que las respuestas sean r치pidas, cuando se habla de complejidaad de algoritmos, se refiere al temporal)

COMPLEJIDAD ESPACIAL
Se refiere a la cantidad adicional de memoria que utiliza un programa mientras se ejecuta.
Incluye la memoria asignada para variables, estructuras de datos, pilas de llamadas, entre otros, en funci칩n del tama침o de la entrada. (Este recurso puede ser expandido a trav칠s de servidores o agregando m치s memoria, por lo que no se toma tanto en cuenta al hablar de complejidad de algoritmos)

2. Algoritmos 쯈u칠 es?
- Es una secuencia ordenada y finita de pasos que permiten realizar una actividad o tarea.
- Estos pasos deben ser sucesivos y exactos.
- Debe ser preciso, claro y no ambiguo.
- Cualquier persona que siga los pasos correctamente pueda obtener el resultado deseado.

쮺칩mo se mide la eficiencia de un algoritmo?
Big O (O) => O(n) <= number of operations (n)

Todo problema tiene soluci칩n el tema es cu치nto tiempo me va a llevar

ALGORITMOS EN C칍DIGO
Complejidad constante O(1)
En este caso el tama침o de dicho array ser칤a totalmente indiferente.

const food = ["游", "游꼢", "游꼴", "游꼥"];

function printFirstElement(array) {
  console.log(array[0]);
}

printFirstElement(food);

Categor칤as
O(1) - Constante (no hay for ni while)
O(log n) - Logar칤tmica (un while que divide a la mitad)
O(n) - Lineal (hay un for que no divide a la mitad)
O(n log n) - Lineal logar칤tmica
O(n^2) - Cuadr치tica (for dentro de otro for)
O(2^n) - Exponencial (un subset y genera un arrego de otro arreglo, combinaciones)

Algoritmos de B칰squeda
Son m칠todos sistem치ticos que se usan para localizar la ubicaci칩n de un elemento particular dentro de un conjunto de datos.
Son fundamentales en la resoluci칩n de problemas relacionados con la recuperaci칩n de informaci칩n.

B칰squeda Lineal
Se recorrer치 el array de principio a fin comparando cada elemento con el valor objetivo.
En el peor de los casos, este valor coincide con el 칰ltimo elemento del array, el tiempo de resoluci칩n ser치 proporcional al tama침o de dicho arreglo.

const list = [
  1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
];

const linealSearch = (array, target) => {
  for (let i = 0; i < array.length; i++) {
    if (array[i] === target) {
      return `El n칰mero ${target} se encuentra en la posici칩n ${i} del array.`;
    }
  }
  return `El n칰mero ${target} no se encuentra en el array.`;
};

console.log(linealSearch(list, 1));
console.log(linealSearch(list, 22));;firstElement(food);

Binary Search
Este algoritmo consiste en encontrar el valor intermedio del array ordenado y compararlo con el valor objetivo.

const binarySearch = (array, target) => {
  let left = 0;
  let right = array.length - 1;
  while (left <= right) {
    let middle = Math.floor((left + right) / 2);
    if (array[middle] === target) {
      return `El n칰mero ${target} se encuentra en la posici칩n ${middle} del array.`;
    }
    if (array[middle] < target) {
      left = middle + 1;
    } else {
      right = middle - 1;
    }
  }
  return `El n칰mero ${target} no se encuentra en el array.`;
};

console.log(binarySearch(list, 1));
console.log(binarySearch(list, 22));

Bubble Sort
Compara elementos de a pares y los ordena dentro de un array.
Este proceso se repetir치 hasta que los datos est칠n ordenados.

const datosDesordenados = [5, 3, 7, 1, 2, 8, 4, 9, 6, 10];

function bubbleSort(array) {

  let cambio = true;

  while (cambio) {
    cambio = false;
    for (let i = 0; i < array.length - 1; i++) {
      if (array[i] > array[i + 1]) {
        let aux = array[i];
        array[i] = array[i + 1];
        array[i + 1] = aux;
        cambio = true;
      }
    }
  }

  return array;
}

console.log(bubbleSort(datosDesordenados));

Merge Sort
Divide: Divide el array desordenado en dos sublistas de tama침o aproximadamente igual.
Ordena: Ordena recursivamente cada sublista. Este paso se repite hasta que cada sublista tenga un solo elemento, lo que se considera que est치 ordenado.
Combina(merge): Combina las sublistas ordenadas para producir una lista 칰nica y ordenada.

Referencias
Links
Calculadora de Logaritmos en Base 2
https://miniwebtool.com/es/log-base-2-calculator/
Video sobre doblar papel
https://www.youtube.com/shorts/35loZtGK38k
Algoritmos
https://github.com/sangaray/ft53-m3-demo/blob/main/Xtras/readmes/m3-14.md

API VIDEO GAMES PARA PRACTICAR
https://www.freetogame.com/api-doc
https://www.freetogame.com/api/games