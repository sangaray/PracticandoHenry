M4FE-L6 - Daiana
NEXTJS COMPONENTS
Si tengo un componente que necesita o utiliza un hook este se va a renderizar del lado del cliente
Cuando se usan los componentes del cliente dependen de si la solicitud es una carga completa o si es una navegación posterior
Si es una carga completa, el componente se renderiza del lado del cliente. Si es una navegación posterior, el componente se renderiza del lado del servidor.
El componente que se renderiza del lado del servidor se renderiza en el servidor y luego se envía al cliente. El componente que se renderiza del lado del cliente se renderiza en el cliente.

Al usar variables de entorno en next debemos llamar al archivo .env.local y dentro de este archivo debo poner
NEXT_PUBLIC_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3000/api
etc.

No se puede usar variables de entorno en el lado del servidor, cuando debe estar del lado del cliente
Para solucionar esto debemos instalar un nuevo paquete llamado server-only
Este paquete va a indicar los errores que se están comentiendo.

También existe el paquete client-only que nos va a indicar los errores que se están cometiendo en el lado del cliente.

npx npq install -dependencia- para verificar la dependencia en el package.json

M4FE-L6 - Maxi
SERVER COMPONENTS VS CLIENT COMPONENTS
Comprensión de Componentes del Servidor
Componentes del Servidor

- Next.js radica en su enforque de creación y uso de componentes del servidor.
- Cada componente que creamos dentro de Next.js se considera un Server Component.El componente character es... ¿asíncrono?

import { fetchServerResponse } from "next/dist/client/components/router-reducer/fetch-server-response";
import React from "react";

const fetchCharacter = async (): Promise<typeof fetchServerResponse> => {
const response = await fetch("https://rickandmortyapi.com/api/character/1");
const character = await response.json();
return character;
};

const Character = async (): Promise<React.JSX.Element> => {
const character = await fetchCharacter();
return <div>{JSON.stringify(character)}</div>;
};

Cuando se crea un componente nuevo, Next.js lo toma como client component, al ejecutarlo, se levanta y carga todo lo que necesita desde el servidor y luego devuelve al cliente el HTML resultante
Para indicar que queremos trabajar con un componente del cliente se escribe en la primera línea antes de los imports
"use client"

Cosas a Tener en Cuenta
Cliente Component: usarlo sólo cuando sea necesario y ailarlos, no hacerlos globales

Al trabajar con componentes de servidor, se puede pedir al componente que espere una respuesta antes de renderizarse. Esto se hace con el await y el async.

server components: los que de mostrar información, no interactuar
client components: con los que se interactua, formularios y botones. Se usa sólo para formularios e interacción que tenga que tener el usuario.

Para next todos los componentes que se crean son server components pueden ser asincrónicos y esperar una respuesta de una petición asincrónica, guardar la respuesta y renderizarla directamente en pantalla.
Los client components los vamos ausar solamente cuando tengamos interacción del usuario y alguna api de react, un redux, algún hook.

Beneficios de los Componentes del Servidor
Seguridad
Te permiten mantener datos y lógica sensibles en el servidor, como tokens y claves de API, sin riesgo de exponerlos al cliente.
Cache

- Al renderizar en el servidor, el resultado puede ser almacenado en caché.
- Puede ser reutilizado en solicitudes posteriores y entre usuarios.
- Puede mejorar el rendimiento y reducir costos al bajar la cantidad de renderizaciones y obtención de datos realizada en cada solicitud.
  Tamaños de Paquetes
- Permiten mantener dependencias grandes que previamente podrían afectal el tamaño del paquete de JavaScript del lado cliente
- Es beneficioso para los usuarios con una conexión a internet más lente o dispositivos menos potentes.

Estrategias de Renderizado del Servidor
Renderización estática

- Es la renderización por defecto en Next.js.
- Esta implica generar y almacenar las páginas como archivos estáticos durante la fase de compilación.
- Ofrece un rendimiento mejorado al entregar contenido pregenerado sin la necesidad de ejecutar lógica del servidor en cada solicitud.
- Es útil cuando una ruta tiene datos que no están personalizados para el usuario y que pueden conocerse en el momento de la compilación.

Renderización dinámica

- Las rutas se representan para cada usuario en el momento de la solicitud, mejorando la personalización y la eficiencia en la entrega de contenido web.
- Permite generar páginas con contenido que se adapta a los datos y contextos específicos de cada petición del usuario.
- Es ideal cuando una ruta tiene datos personalizados para el usuario o tiene información que solo se puede conocer en el momento de la solicitud.

Cambiando de Renderizado Estático a Dinámico

- Durante el renderizado, si se descubre una función dinámica o una solicitud de datos no almacenados en caché, Next.js cambiará para renderizar
  Funciones dinámicas Datos Ruta
  No En caché Renderizado estáticamente
  Sí En caché Renderizado dinámicamente
  No No almacenado en caché Renderizado dinámicamente
  Sí No almacenado en caché Renderizado dinámicamente

Comprensión de Componentes del Cliente
Componentes del Cliente

- Son herramientas que posibilitan la creación de interfaces de usuario más dinámicas y receptivas.
- Pueden ser visualizadas por el cliente al realizar una solicitud.
- En Next.js el uso de estos componentes es opcional.
- Debemos especificar qué componentes deben renderizarse en el lado cliente.

Uso de componentes del cliente

- Utiliza la directiva 'use client' al inicio del componente.
- Se utiliza para declarar un límite entre los módulos de un servidor y un componente de cliente.

"use client";
import Button from "@/components/Button/Button";
import React from "react";

¿Cómo se representan los componentes del cliente?
Carga de página completa
Para optimizar la carga de la página inicial, Next.js utilizará las API de React para representar una vista previa HTML estática en el servidor para ambos componentes (cliente y servidor).
Navegación posterior
En las navegaciones siguientes, los componentes del cliente se muestran solo en el navegador, sin utilizar el HTML generado por el servidor.

Beneficios de los componentes del cliente
Interactividad

- Permiten crear experiencias web altamente interactivas y dinámicas.
- Ejecutan lógica en el navegador del usuario sin requerir una nueva solicitud al servidor.
  Velocidad de carga
- Mejoran la velocidad de carga inicial de la página al delegar la renderización y la lógica de presentación al navegador del cliente.
  Reduce la carga en el servidor y optimizando los tiempos de respuesta.
  Separación de preocupaciones
  Facilitan la separación de la lógica del cliente y del servidor.
- Permite un desarrollo más modular y mantenible al dividir la aplicación en componentes reutilizables.

Flujo de Datos de Componentes del Servidor
Patrones de componentes del servidor

- Son estrategias y técnicas utilizadas para estructurar y gestionar la lógica del lado del servidor.- Permite la renderización eficiente de contenido y la optimización del rendimiento de la aplicación web

Compartir datos entre componentes

- Es posible que al recuperar datos del servidor, queramos compartirlos con otro componente, es decir, que tengamos dos componentes dependientes de la misma información.
- Next.js nos proporciona una solución bastante óptima para estas situaciones.
- Se basa en la particularidad de cómo trabaja Next.js con la obtención de datos o fetching.
- Next.js almacena los datos en caché y nos permite luego acceder a ellos sin necesidad de tener que hacer la consulta nuevamente.

Manteniendo código del servidor fuera del entorno del cliente

- Es importante recordar que los módulos de JavaScript pueden ser compartidos entre componentes de servidor y cliente.
- Esto puede llevarnos a cometer el error de utilizar código que está diseñado únicamente en el servidor, para ejecutarse en el cliente.
- Es fundamental realizar una correcta gestión de esto para evitar posibles problemas y asegurar el correcto funcionamiento tanto de ambos lados.

Usando paquetes de terceros

- Cuando utilizamos paquetes y proveedores de terceros en un proyecto con Next.js, es crucial tener en cuenta que el concepto de componentes del servidor es relativamente nuevo en el mercado.
- Algunos desarrolladores de estos paquetes pueden no haber actualizado sus herramientas para incluir la directiva "use client" cuando sea necesario.

- Cuando utilicemos <Slider /> dentro de un componente del cliente, funcionará como esperamos.

"use client";
import { useState } from 'react';
import { Slider } from 'henry-slider';

function Gallery() {
let [isOpen, setIsOpen] = useState(false);

return (

<div>
<button onClick={() => setIsOpen(true)}>View pictures</button>
{/_ Funcionaría, porque está siendo usado en un componente del cliente _/}
{isOpen && <Slider />}
</div>
);
}

- Cuando lo utilicemos en un componente del servidor, nos encontramos con un error.

import { Slider } from 'henry-slider';

function Galeria() {
  return (
    <div>
      <p>View Pictures</p>
      {/* Error: 'useState' can not be user within Server Components */}
      <Slider />
    </div>
  );
}

👉 Envuelve el componente de terceros que depende de estas funcionalidades de componentes del cliente, en otro nuevo componente.
Nuevo componente Wrapper (Ej: Slider.js):

"use client";
import { Slider } from "henry-slider";

export default Slider;
Componente de Servidor (Ej: Galeria.js):

import { Slider } from "@componentes/Slider";

function Galeria() {
  return (
    <div>
      <p>View Pictures</p>
      {/* Ahora sí funcionaría porque lo encerramos en la directiva 'use client' */}
      <Slider />
    </div>
  );
}

Proveedores de contexto en componentes del servidor
- Son una herramienta para nuestras aplicaciones.
- Permiten compartir datos entre varios componentes sin tener que pasar propiedades manualmente.
- Varios gestores de estados globales se basan en ellos y los utilizan internamente para su funcionamiento.

 Crear el proveedor de contexto dentro de un componente del cliente.

"use client";
import { createContext } from "react";

const ThemeContext = createContext({});

function ThemeProvider({children}: {children: React.ReactNode}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}

- En el componente del servidor, renderiza el proveedor de contexto.
- De esta manera, accede a este SOLO desde nuestros otros componentes del cliente.

import ThemeProvider from "./apptheme-provider";

function RootLayout({children}: {children: React.ReactNode}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  );
}

+++ Ver sobre Server Actions +++

Flujo de Datos de Componentes del Cliente
Patrones de componentes del cliente
- Son enfoques y prácticas de desarrollo que aprovechan, en este caso, la capacidad de ejecutar lógica en el navegador del usuario.
- Estos patrones permiten crear experiencias interactivas, dinámicas y eficientes, en las aplicaciones web construidas con Next.js.

Optimizando la ubicación de nuestros componentes del cliente en el árbol
- Cuando trabajamos con componentes del cliente, debemos esforzarnos por ubicarlos en la parte más baja posible de nuestro árbol de componentes.
(La imagen muestra un árbol frondoso que representa los "Server Components" y las hojas individuales en las ramas representan los componentes con la directiva "use client").

- Buscamos reducir el tamaño del paquete de Javascript del cliente.

import SearchBar from "../components/SearchBar/SearchBar";
import Logo from "../components/Logo/Logo";

// Layout es un componente del servidor por defecto.
function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  );
}

👉 Pasando datos por 'props' de un componente del servidor al cliente
Soportados	    No Soportados
Primitivos:	    React elements, o JSX
- string     	  Functions, incluyendo funciones de componente o cualquier otra función que no sea una acción del servidor
- number	      Classes
- bigint	      Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype
- boolean	      Symbols not registered globally, ex. Symbol('my new symbol')
- undefined	
- null	
- symbol, sólo símbolos registrados globalmente a través de Symbol.for	
Iterables que contienen valores serializables (primitivas):	
- Date	
- Instancias de FormData	
Objetos planos: aquellos creados con inicializadores de objetos, con propiedades serializables	
Funciones que son acciones del servidor	
Promesas