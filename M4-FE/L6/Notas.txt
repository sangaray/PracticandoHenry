M4FE-L6 - Daiana
NEXTJS COMPONENTS
Si tengo un componente que necesita o utiliza un hook este se va a renderizar del lado del cliente
Cuando se usan los componentes del cliente dependen de si la solicitud es una carga completa o si es una navegaci칩n posterior
Si es una carga completa, el componente se renderiza del lado del cliente. Si es una navegaci칩n posterior, el componente se renderiza del lado del servidor.
El componente que se renderiza del lado del servidor se renderiza en el servidor y luego se env칤a al cliente. El componente que se renderiza del lado del cliente se renderiza en el cliente.

Al usar variables de entorno en next debemos llamar al archivo .env.local y dentro de este archivo debo poner
NEXT_PUBLIC_URL=http://localhost:3000
NEXT_PUBLIC_API_URL=http://localhost:3000/api
etc.

No se puede usar variables de entorno en el lado del servidor, cuando debe estar del lado del cliente
Para solucionar esto debemos instalar un nuevo paquete llamado server-only
Este paquete va a indicar los errores que se est치n comentiendo.

Tambi칠n existe el paquete client-only que nos va a indicar los errores que se est치n cometiendo en el lado del cliente.

npx npq install -dependencia- para verificar la dependencia en el package.json

M4FE-L6 - Maxi
SERVER COMPONENTS VS CLIENT COMPONENTS
Comprensi칩n de Componentes del Servidor
Componentes del Servidor

- Next.js radica en su enforque de creaci칩n y uso de componentes del servidor.
- Cada componente que creamos dentro de Next.js se considera un Server Component.El componente character es... 쯔s칤ncrono?

import { fetchServerResponse } from "next/dist/client/components/router-reducer/fetch-server-response";
import React from "react";

const fetchCharacter = async (): Promise<typeof fetchServerResponse> => {
const response = await fetch("https://rickandmortyapi.com/api/character/1");
const character = await response.json();
return character;
};

const Character = async (): Promise<React.JSX.Element> => {
const character = await fetchCharacter();
return <div>{JSON.stringify(character)}</div>;
};

Cuando se crea un componente nuevo, Next.js lo toma como client component, al ejecutarlo, se levanta y carga todo lo que necesita desde el servidor y luego devuelve al cliente el HTML resultante
Para indicar que queremos trabajar con un componente del cliente se escribe en la primera l칤nea antes de los imports
"use client"

Cosas a Tener en Cuenta
Cliente Component: usarlo s칩lo cuando sea necesario y ailarlos, no hacerlos globales

Al trabajar con componentes de servidor, se puede pedir al componente que espere una respuesta antes de renderizarse. Esto se hace con el await y el async.

server components: los que de mostrar informaci칩n, no interactuar
client components: con los que se interactua, formularios y botones. Se usa s칩lo para formularios e interacci칩n que tenga que tener el usuario.

Para next todos los componentes que se crean son server components pueden ser asincr칩nicos y esperar una respuesta de una petici칩n asincr칩nica, guardar la respuesta y renderizarla directamente en pantalla.
Los client components los vamos ausar solamente cuando tengamos interacci칩n del usuario y alguna api de react, un redux, alg칰n hook.

Beneficios de los Componentes del Servidor
Seguridad
Te permiten mantener datos y l칩gica sensibles en el servidor, como tokens y claves de API, sin riesgo de exponerlos al cliente.
Cache

- Al renderizar en el servidor, el resultado puede ser almacenado en cach칠.
- Puede ser reutilizado en solicitudes posteriores y entre usuarios.
- Puede mejorar el rendimiento y reducir costos al bajar la cantidad de renderizaciones y obtenci칩n de datos realizada en cada solicitud.
  Tama침os de Paquetes
- Permiten mantener dependencias grandes que previamente podr칤an afectal el tama침o del paquete de JavaScript del lado cliente
- Es beneficioso para los usuarios con una conexi칩n a internet m치s lente o dispositivos menos potentes.

Estrategias de Renderizado del Servidor
Renderizaci칩n est치tica

- Es la renderizaci칩n por defecto en Next.js.
- Esta implica generar y almacenar las p치ginas como archivos est치ticos durante la fase de compilaci칩n.
- Ofrece un rendimiento mejorado al entregar contenido pregenerado sin la necesidad de ejecutar l칩gica del servidor en cada solicitud.
- Es 칰til cuando una ruta tiene datos que no est치n personalizados para el usuario y que pueden conocerse en el momento de la compilaci칩n.

Renderizaci칩n din치mica

- Las rutas se representan para cada usuario en el momento de la solicitud, mejorando la personalizaci칩n y la eficiencia en la entrega de contenido web.
- Permite generar p치ginas con contenido que se adapta a los datos y contextos espec칤ficos de cada petici칩n del usuario.
- Es ideal cuando una ruta tiene datos personalizados para el usuario o tiene informaci칩n que solo se puede conocer en el momento de la solicitud.

Cambiando de Renderizado Est치tico a Din치mico

- Durante el renderizado, si se descubre una funci칩n din치mica o una solicitud de datos no almacenados en cach칠, Next.js cambiar치 para renderizar
  Funciones din치micas Datos Ruta
  No En cach칠 Renderizado est치ticamente
  S칤 En cach칠 Renderizado din치micamente
  No No almacenado en cach칠 Renderizado din치micamente
  S칤 No almacenado en cach칠 Renderizado din치micamente

Comprensi칩n de Componentes del Cliente
Componentes del Cliente

- Son herramientas que posibilitan la creaci칩n de interfaces de usuario m치s din치micas y receptivas.
- Pueden ser visualizadas por el cliente al realizar una solicitud.
- En Next.js el uso de estos componentes es opcional.
- Debemos especificar qu칠 componentes deben renderizarse en el lado cliente.

Uso de componentes del cliente

- Utiliza la directiva 'use client' al inicio del componente.
- Se utiliza para declarar un l칤mite entre los m칩dulos de un servidor y un componente de cliente.

"use client";
import Button from "@/components/Button/Button";
import React from "react";

쮺칩mo se representan los componentes del cliente?
Carga de p치gina completa
Para optimizar la carga de la p치gina inicial, Next.js utilizar치 las API de React para representar una vista previa HTML est치tica en el servidor para ambos componentes (cliente y servidor).
Navegaci칩n posterior
En las navegaciones siguientes, los componentes del cliente se muestran solo en el navegador, sin utilizar el HTML generado por el servidor.

Beneficios de los componentes del cliente
Interactividad

- Permiten crear experiencias web altamente interactivas y din치micas.
- Ejecutan l칩gica en el navegador del usuario sin requerir una nueva solicitud al servidor.
  Velocidad de carga
- Mejoran la velocidad de carga inicial de la p치gina al delegar la renderizaci칩n y la l칩gica de presentaci칩n al navegador del cliente.
  Reduce la carga en el servidor y optimizando los tiempos de respuesta.
  Separaci칩n de preocupaciones
  Facilitan la separaci칩n de la l칩gica del cliente y del servidor.
- Permite un desarrollo m치s modular y mantenible al dividir la aplicaci칩n en componentes reutilizables.

Flujo de Datos de Componentes del Servidor
Patrones de componentes del servidor

- Son estrategias y t칠cnicas utilizadas para estructurar y gestionar la l칩gica del lado del servidor.- Permite la renderizaci칩n eficiente de contenido y la optimizaci칩n del rendimiento de la aplicaci칩n web

Compartir datos entre componentes

- Es posible que al recuperar datos del servidor, queramos compartirlos con otro componente, es decir, que tengamos dos componentes dependientes de la misma informaci칩n.
- Next.js nos proporciona una soluci칩n bastante 칩ptima para estas situaciones.
- Se basa en la particularidad de c칩mo trabaja Next.js con la obtenci칩n de datos o fetching.
- Next.js almacena los datos en cach칠 y nos permite luego acceder a ellos sin necesidad de tener que hacer la consulta nuevamente.

Manteniendo c칩digo del servidor fuera del entorno del cliente

- Es importante recordar que los m칩dulos de JavaScript pueden ser compartidos entre componentes de servidor y cliente.
- Esto puede llevarnos a cometer el error de utilizar c칩digo que est치 dise침ado 칰nicamente en el servidor, para ejecutarse en el cliente.
- Es fundamental realizar una correcta gesti칩n de esto para evitar posibles problemas y asegurar el correcto funcionamiento tanto de ambos lados.

Usando paquetes de terceros

- Cuando utilizamos paquetes y proveedores de terceros en un proyecto con Next.js, es crucial tener en cuenta que el concepto de componentes del servidor es relativamente nuevo en el mercado.
- Algunos desarrolladores de estos paquetes pueden no haber actualizado sus herramientas para incluir la directiva "use client" cuando sea necesario.

- Cuando utilicemos <Slider /> dentro de un componente del cliente, funcionar치 como esperamos.

"use client";
import { useState } from 'react';
import { Slider } from 'henry-slider';

function Gallery() {
let [isOpen, setIsOpen] = useState(false);

return (

<div>
<button onClick={() => setIsOpen(true)}>View pictures</button>
{/_ Funcionar칤a, porque est치 siendo usado en un componente del cliente _/}
{isOpen && <Slider />}
</div>
);
}

- Cuando lo utilicemos en un componente del servidor, nos encontramos con un error.

import { Slider } from 'henry-slider';

function Galeria() {
  return (
    <div>
      <p>View Pictures</p>
      {/* Error: 'useState' can not be user within Server Components */}
      <Slider />
    </div>
  );
}

游녤 Envuelve el componente de terceros que depende de estas funcionalidades de componentes del cliente, en otro nuevo componente.
Nuevo componente Wrapper (Ej: Slider.js):

"use client";
import { Slider } from "henry-slider";

export default Slider;
Componente de Servidor (Ej: Galeria.js):

import { Slider } from "@componentes/Slider";

function Galeria() {
  return (
    <div>
      <p>View Pictures</p>
      {/* Ahora s칤 funcionar칤a porque lo encerramos en la directiva 'use client' */}
      <Slider />
    </div>
  );
}

Proveedores de contexto en componentes del servidor
- Son una herramienta para nuestras aplicaciones.
- Permiten compartir datos entre varios componentes sin tener que pasar propiedades manualmente.
- Varios gestores de estados globales se basan en ellos y los utilizan internamente para su funcionamiento.

 Crear el proveedor de contexto dentro de un componente del cliente.

"use client";
import { createContext } from "react";

const ThemeContext = createContext({});

function ThemeProvider({children}: {children: React.ReactNode}) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}

- En el componente del servidor, renderiza el proveedor de contexto.
- De esta manera, accede a este SOLO desde nuestros otros componentes del cliente.

import ThemeProvider from "./apptheme-provider";

function RootLayout({children}: {children: React.ReactNode}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  );
}

+++ Ver sobre Server Actions +++

Flujo de Datos de Componentes del Cliente
Patrones de componentes del cliente
- Son enfoques y pr치cticas de desarrollo que aprovechan, en este caso, la capacidad de ejecutar l칩gica en el navegador del usuario.
- Estos patrones permiten crear experiencias interactivas, din치micas y eficientes, en las aplicaciones web construidas con Next.js.

Optimizando la ubicaci칩n de nuestros componentes del cliente en el 치rbol
- Cuando trabajamos con componentes del cliente, debemos esforzarnos por ubicarlos en la parte m치s baja posible de nuestro 치rbol de componentes.
(La imagen muestra un 치rbol frondoso que representa los "Server Components" y las hojas individuales en las ramas representan los componentes con la directiva "use client").

- Buscamos reducir el tama침o del paquete de Javascript del cliente.

import SearchBar from "../components/SearchBar/SearchBar";
import Logo from "../components/Logo/Logo";

// Layout es un componente del servidor por defecto.
function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  );
}

游녤 Pasando datos por 'props' de un componente del servidor al cliente
Soportados	    No Soportados
Primitivos:	    React elements, o JSX
- string     	  Functions, incluyendo funciones de componente o cualquier otra funci칩n que no sea una acci칩n del servidor
- number	      Classes
- bigint	      Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype
- boolean	      Symbols not registered globally, ex. Symbol('my new symbol')
- undefined	
- null	
- symbol, s칩lo s칤mbolos registrados globalmente a trav칠s de Symbol.for	
Iterables que contienen valores serializables (primitivas):	
- Date	
- Instancias de FormData	
Objetos planos: aquellos creados con inicializadores de objetos, con propiedades serializables	
Funciones que son acciones del servidor	
Promesas

Interpolaci칩n de componentes de servidor y cliente
- Nos referimos a la integraci칩n y combinaci칩n de elementos renderizados tanto en el servidor como en el cliente en una aplicaci칩n web.
- Esto implica la utilizaci칩n de ambos tipos de componentes.
- Con el servidor generando parte del contenido de la p치gina y el cliente a침adiendo o modificando elementos adicionales despu칠s de que la p치gina se haya cargado inicialmente.

Importar componentes de servidor a componentes de cliente - NO ADMITIDO
- No podemos importar un componente del servidor dentro de un componente del cliente.

import { useState } from 'react'
"use client"

// Esto est치 completamente prohibido.
// No se puede importar C. de servidor en el cliente.
import ServerComponent from './ServerComponent'

function ClientComponent({children}: {children: React.ReactNode}) {
  const [count, setCount] = useState(0)

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      <ServerComponent />
    </>
  )
}

Pasar componentes del servidor a cliente como 'props' - ADMITIDO
- Este patr칩n admitido nos permite pasarle un componente del servidor al cliente como 'props'.

"use client";
import { useState } from 'react';

function ClientComponent({children}: {children: React.ReactNode}) {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  );
}

- En un componente servidor padre, puedes importar tanto al ClientComponent como al ServerComponent y pasar este 칰ltimo como un hijo del primero.

// Pasamos el C. de servidor como 'children' por props al C. de cliente
import ClientComponent from './ClientComponent';
import ServerComponent from './ServerComponent';

// Pages en Next.js son componentes del servidor por defecto
function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  );
}


